#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Dictionary Generator Script

Generates multiple inclusive dictionary variants from a source dictionary.
Creates dictionaries with different markers (-e, -x, @) and modes (aggressive, conservative).
"""

import argparse
import os
import sys
import json
from pathlib import Path
import zipfile
import io

# Add the src directory to the path
project_root = Path(__file__).parent.parent
src_path = project_root / 'src'
sys.path.insert(0, str(src_path))

from conversor_inclusivo import ConversorInclusivo

def generate_dictionary_variants(input_file, output_dir, markers=None, modes=None, formats=None):
    """
    Generate multiple dictionary variants from a source dictionary.
    
    Args:
        input_file: Path to the input dictionary file.
        output_dir: Directory where output files will be saved.
        markers: List of markers to use. Defaults to ['e', 'x', '@'].
        modes: List of modes to use. Defaults to ['aggressive', 'conservative'].
        formats: List of output formats. Defaults to ['json'].
    """
    if markers is None:
        markers = ['e', 'x', '@']
    
    if modes is None:
        modes = ['aggressive', 'conservative']
    
    if formats is None:
        formats = ['json']
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Generate dictionaries for each combination
    for marker in markers:
        for mode in modes:
            # Create converter with specified marker and mode
            conversor = ConversorInclusivo(marker=marker, mode=mode)
            
            # Create output files for each format
            for format in formats:
                # Generate the output filename
                mode_suffix = 'reemplazo' if mode == 'aggressive' else 'adicion'
                marker_suffix = f"e" if marker == 'e' else f"{'x' if marker == 'x' else 'arroba'}"
                
                output_filename = f"es_inclusive_{mode_suffix}_{marker_suffix}.{format}"
                output_path = os.path.join(output_dir, output_filename)
                
                # Process the input file and generate the output
                print(f"Generating {output_path}...")
                words = conversor.procesar_archivo(input_file, output_path, output_format=format)
                
                # Generate ZIP file for web distribution if JSON format
                if format == 'json':
                    print(f"Creating ZIP for {output_filename}...")
                    create_zip_dictionary(output_path, output_path.replace('.json', '.zip'))

def create_zip_dictionary(json_path, zip_path):
    """
    Create a ZIP file containing the dictionary for web distribution.
    
    Args:
        json_path: Path to the JSON dictionary file.
        zip_path: Path where the ZIP file will be saved.
    """
    try:
        # Read the dictionary data
        with open(json_path, 'r', encoding='utf-8') as f:
            dictionary = json.load(f)
        
        # Create a README file with metadata
        readme_content = f"""# {dictionary['name']}

{dictionary['description']}

Version: {dictionary['version']}
Words: {len(dictionary['words'])}

Generated by conversor_inclusivo.
"""
        
        # Create the ZIP file
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # Add the JSON file
            arcname = os.path.basename(json_path)
            zipf.write(json_path, arcname)
            
            # Add the README file
            zipf.writestr('README.md', readme_content)
        
        print(f"  - Created {zip_path}")
    except Exception as e:
        print(f"Error creating ZIP file: {e}")

def copy_to_static_dictionaries(output_dir):
    """
    Copy JSON dictionaries to the public/static/dictionaries directory for web use.
    
    Args:
        output_dir: Directory containing the generated dictionaries.
    """
    static_dir = project_root / 'public' / 'static' / 'dictionaries'
    os.makedirs(static_dir, exist_ok=True)
    
    # Copy all JSON files
    for file in Path(output_dir).glob('*.json'):
        dest_path = static_dir / file.name
        print(f"Copying {file.name} to static directory...")
        
        # Copy the file
        with open(file, 'r', encoding='utf-8') as src, open(dest_path, 'w', encoding='utf-8') as dst:
            dst.write(src.read())

def main():
    """Main function to parse arguments and run the generator."""
    parser = argparse.ArgumentParser(
        description="Generate multiple inclusive dictionary variants.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    parser.add_argument(
        "input_file",
        help="Path to the input dictionary file."
    )
    parser.add_argument(
        "-o", "--output-dir",
        default=str(project_root / 'public' / 'dictionaries'),
        help="Directory where output files will be saved."
    )
    parser.add_argument(
        "--markers",
        nargs='+',
        choices=['e', 'x', '@'],
        default=['e', 'x', '@'],
        help="Markers to use for inclusive forms."
    )
    parser.add_argument(
        "--modes",
        nargs='+',
        choices=['aggressive', 'conservative'],
        default=['aggressive', 'conservative'],
        help="Processing modes to use."
    )
    parser.add_argument(
        "--formats",
        nargs='+',
        choices=['json', 'plaintext', 'hunspell'],
        default=['json'],
        help="Output formats to generate."
    )
    parser.add_argument(
        "--copy-to-static",
        action="store_true",
        help="Copy JSON dictionaries to public/static/dictionaries for web use."
    )
    
    args = parser.parse_args()
    
    # Validate input file
    if not os.path.exists(args.input_file):
        print(f"Error: Input file not found: {args.input_file}")
        sys.exit(1)
    
    # Generate dictionary variants
    generate_dictionary_variants(
        args.input_file,
        args.output_dir,
        args.markers,
        args.modes,
        args.formats
    )
    
    # Copy to static directory if requested
    if args.copy_to_static:
        copy_to_static_dictionaries(args.output_dir)
    
    print("Dictionary generation complete!")

if __name__ == "__main__":
    main()